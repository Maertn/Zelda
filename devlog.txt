I'll keep the devlog.txt open as a devlog / notepad.

# Setting up GitHub
The first thing that I'll try to do is push this README onto github and switch to a branch. 
After the first part of the tutorial is done I'll merge to main.
One problem that might emerge is excluding the virtual environment from the commit. I'll be experimenting with .gitignore.
I think I've already set up configuration for connecting with GitHub from VSCode, so I'll be good to go.

I realised that README.txt is printed in GitHub, so I've switched to another file for keeping track.
I made an .gitignore and tested it with success. I'll create a venv and add it to ignored files. 

I wanted to make a last change by installing pygame and updating requirements.txt. 
I couldn't push with Git, and realised that I'd already switched branches.
To my amazement, with requirements.txt open, I can see the content change when I switch branches through console.
I'll set upstream for my new branch 1.level, named after the folder in the original project (https://github.com/clear-code-projects/Zelda)

--
2023-03-15 #1
--
1. Level

I've created main.py with a class Game.
In Game pygame is initialized. A screen and clock are properties.
One method is currently written, run(), which is the main loop.
run() currently does four things:
1. run() checks for event.type == pygame.QUIT through pygame.event.get().
2. the display is filled with black
3. the update method for the display is called
4. the clock ticks

Screen properties are taken from settings.py, where currently width and heigth are hardcoded, alongside a map.

At the end of the script we get: 
if __name__ == '__main__':  # when main.py is called:
    game = Game()           # create an object from Game()
    game.run()              # call method run() from game

I'm just writing all this stuff down since I'm new to OOP, and this is my way of teaching myself.
Coming up is a simple debugging tool.

Changed display caption to 'Zelda'. 
I noticed that I'm one line off already with the tutorial. This is because I insisted to import pygame as pg.
Corrected the number of lines by removing a comment stating # general setup. Seemed rather superfluous anyway.

If I'm understanding correctly we're going to create seperate groups. Each sprite can belong to multiple groups. 
Within the groups certain behaviour are described. 
Depending on which groups a sprite belongs to it can exhibit behaviour such as being visible or being an obstacle.

Three new files are created, level.py, tile.py and player.py, each containing one class. 
tile.py and player.py describe two different sprites.
tile.py contains a rock, player.py contains the player.
Within settings we find a map which contains three different entries: rock ('x'), player('p') and empty space(' ').
The third file, level.py, is the most interesting right now. It contains a class, Level, which loads all the sprites.
The drawing and updating of the sprites is also executed within Level with the method run().
Level needs to be drawn to the screen, so we get the display surface with self.display_surface = pygame.display.get_surface. I'm a bit iffy about how that works tho.
main.py is updated to import Level as a property, then our main loop calls level.run().

We've created a neat few lines which scans the WORLD_MAP in settings, and when 'x' or 'p' draw rock or player to display_surface.
This is a method in Level, which is called during initialization of the Level class.
I'm coding along, but I keep bumping into little things I couldn't predict. I'll try to dissect what happened.
visible_sprites is a property of Level. It inherits from the Group() class in pygame.sprite. 
When I'm creating classes for the game, i.e. rock, I'm adding groups(note:plural) as an argument to be passed when calling the Tile() class.
Tile() is a class that inherits from the Sprite() class in pygame.sprite.
In the script a Tile() is called with a group in the parameter. if 'x' -> Tile((x, y), [self.visible_sprites])
Level() contains method run(), in which we'll draw members from visible_sprites. I'll write it out in full:
def run(self):
    self.visible_sprites.draw(self.display_screen)
I first attempted to simply give 'self' as argument, but that returned an error, saying that 'Level'obj has no blit.
But giving self.display_screen did work. I guess the blit is stored in display_screen as a property which cannot be read directly?

I think I know what's happening, but I don't want to be 80% sure. Guess I'll read up on Sprite() and Group() in the pygame docs.
I'll also ask ChatGTP about OOP nomenclature, since I'm not even sure if I'm describing certain terms correctly in this document. 
I'll commit and push to GitHub. I'm at 26:45. Might continue a bit later after reading, chatting and walking with Shadow, might go to bed.

--
2023-16-03
#1
--
I finished a crash course on OOP. Also looked into the pygame docs regarding sprites. 
I've learned that I can simply call doc to see the description of a class. Might save some time.

Struggled a bit to include __pycache__ in .gitignore. Got it working tho by leaving out the "/" at the end, which is common for folders.
Finished the first part of the tutorial. Succesfuly merged the 1.level branch with master, and created a new branch, 2.setup.
I'm currently at 28:37, where the second part of the tutorial starts.

#2
--
The different parts of the tutorial aren't clearly marked, so I messed up with regard to matching the branches to
different parts. I'll just save, push, merge, and create a new branch called 3.move. 

#3
--
Gave Player the ability to detect key presses. The sprite doesn't update it's position tho, at least not visually. This is slightly
confusing since the player does have a position. I think I understand it now; Player has directions, which is a Vector2 from pg.math.
The directions are read, but they aren't integrated to the Player's position.
Also created the debugger.

#4
--
Finished the third part. Input with keys gives the player a direction. The player multiplies this direction with a constant to
acquire speed. The speed results in a movement over x and y. Corrected for diagonal movement giving a sqrt(2) mulitplier.
Collision with obstacles is handled within the Player class through the methods for movement described above.
If the player moves towards the right, the collision detector will keep placing the player's right to the obstacle's left.
This wouldn't work for a moving 'obstacle', say a monster. At least from what I gather from the code, moving to the right
but being intercepted from the left, e.g. a fast moving enemy, will cause this collision detector to place the player to the left of the
enemy, effectively teleporting the player. I can only assume that when enemies are added either the collision detector will be updated,
or another method detecting collision will be created within the enemy classes.
I'd also like to comment that I expected collision to be handled outside of the Player, since collision detection should be
applicable to NPCs as well. Oh well, it'll probably be accounted for as we go along.

I'll push this branch to GitHub, and start branch 4.camera&ysort. Feels like it's coming along nicely.

#5
--
Discovered that merging from my terminal doesn't work in GitHub, for some reason. Maybe I need to push one last time before deleting the 
branch? I merged manually through the browser. As a result, master doesn't contain the merges with 2. and 3., but the branches do
exist individually in GitHub. Merging them now would be redundant, and I could always call on the branches themselves, since I'm probably
not deleting them.

Turns out that the name of the branch has to be 4.camera, since GitHub doesn't allow ampersand in the name. 
In this part we'll be working with pygame's group system, which is very interesting to me, since I've read some documentation 
regarding the Sprite class.

#6
--
We've got a working camera. The geometry is a bit weird tho.
We created a class called YSortCameraGroup. This group is passed to visible_sprites.
visible_sprites used to be a pg.sprite.Sprite.Group(), so it isn't surprising that YSortCameraGroup 
inherits from that class.
Inside that class a custom_draw method is created. It takes the sprites in the class and draws them on the display.
When drawing the sprites an offset is given. This offset makes sure that the camera stays on the player, and places the player
in the center of the display. First we create an empty pg.math.Vector2() inside YSortCameraGroup, named self.offset, 
and then we declare self.offset.x = player.rect.centerx - self.half_width. Similar for self.offset.y.
We give the custom_draw the topleft of a sprite and adjust with self.offset to determine the position to draw.

Most importantly, it works. And it works beautifully. I like how smooth the animation is, while I expected something more discrete.
Thinking back, we did set the tiles to be drawn at distances of 64. Hence the player sprite moves over the 64*64 pixel grid, instead
of moving from grid to grid discretely, as would be the case in an older roguelike.

I'm already thinking about a camera that would snap to enemies, like CDDA. This way you could inspect enemies that are outside
the display but within the players FOV, should one decide to work with such a feature.

#7
--
Done with the 4th part. We've created a camera, as mentioned. We used YSortCameraGroup to track the player across the map.
We've upgraded the YSortCameraGroup to sort over the y axis, checking which object comes first. After creating a list,
the sprites will be drawn in order, so an illusion of depth is created. To make use of this addition, we create an attribute
called hitbox, which'll be self.rect - some of the top and bottom y. Now objects can overlap each other, and we see the player partly
'disappear' behind rocks. Pretty neat.

#8
--
In the next part we'll use Tiled. I'm not sure if it's a module connected to pygame, or independent.
It might pay off to watch a seperate tutorial (which is another 2 hours) devoted to the software. I'm probably done for today in
following the Zelda tutorial, but I might be able to finish the tutorial on Tiled.

#9
--
I forgot to note that in the custom_draw method in Level we sort by changing a for loop to be:
"for sprite in sorted(self.sprites(), key = lambda sprite: sprite.rect.centery):"
I don't really know how the sorted function works, nor do I understand the lambda function.
I know lambda is a thing where you write a small throw-away function, but that doesn't mean that I'm able
to interpret this line. I do know that this loop gets edited to sort for y positions. 
I'll give it my best shot. We're itterating over self.sprites(), which are all the sprites contained in the level.
For each sprite found we're calling custom_draw to draw the sprite to the display.
self.sprites() isn't explicitly declared in the code, so it must be a method contained in pg.sprite.Group(), which our
YSortCameraGroup class inherits from. When printing self.sprites() we see [] in the return. Since we're
atm using YSortCameraGroup exclusively to declare visible_sprites, and the fact that we know the purpose of the function,
we can be certain in describing self.sprites() to return a list containing the sprites that are declared to be visible_sprites.
The function sorted takes (in this case) two arguments: 1. the list to be sorted, and 2. a key that is used to determine which 
attribute is sorted by. We are sorting by a value for y, which explains the mention of sprite.rect.centery. 
Why "lambda sprite: " needs to be given will remain a mystery for now.

The Tiled tutorial was somewhat useful. I watched about 30 minutes of the 120, but I felt like I got the gist of it.
The program seems intuitive enough, and since I have it installed now I can continue the Zelda tutorial.
If I'm having a hard time understanding the usage of Tiled in the tutorial I can always revisit the dedicated tutorial for Tiled.
Seems like we'll be importing the map in this section, so I'm looking forward to having some nice visuals to look at next time
I boot the program.

#10
--
It's quite late. I've added tilesets that draw the map, objects, grass and boundaries.
It was quite complicated after all. I've been working with csv, but I have no idea what that entails.
I've copied a lot of code, but didn't process properly what happens in it. I got the gist of it, but I'll have to return
tomorrow to really interpret what happened here. Guess I'll have to watch that dedicated Tiled tutorial after all. At least
I'll have some background as to what to look out for. There's clearly no point in pushing on now. I'll write more about the
drawing of graphics tomorrow.  I've already merged the branches, so I'll set up the 6th branch to push the devlog.